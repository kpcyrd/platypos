use crate::errors::*;
use crate::srcinfo;
use ruzstd::decoding::{FrameDecoder, StreamingDecoder};
use ruzstd::io::Read;
use sha2::{Digest, Sha256};
use std::fs;
use std::io::Seek;
use std::path::Path;

#[derive(Debug, Default, Clone)]
pub struct Meta {
    pub filename: String,
    pub compressed_size: u64,
    pub sha256: String,
    pub pgpsig: Option<String>,
}

impl Meta {
    pub fn checksum_stream(&mut self, file: &mut fs::File) -> Result<()> {
        let mut sha256 = Sha256::new();

        let mut buf = [0u8; 4096];
        loop {
            let n = file.read(&mut buf)?;
            if n == 0 {
                break;
            }
            sha256.update(&buf[..n]);
            self.compressed_size += n as u64;
        }
        self.sha256 = format!("{:x}", sha256.finalize());

        Ok(())
    }
}

#[derive(Debug, Default, Clone, PartialEq)]
pub struct Pkg {
    pub name: Vec<String>,
    pub base: Vec<String>,
    pub version: Vec<String>,
    pub desc: Vec<String>,
    pub groups: Vec<String>,
    pub url: Vec<String>,
    pub license: Vec<String>,
    pub arch: Vec<String>,
    pub builddate: Vec<String>,
    pub packager: Vec<String>,
    pub size: Vec<String>,
    pub replaces: Vec<String>,
    pub conflicts: Vec<String>,
    pub provides: Vec<String>,
    pub depends: Vec<String>,
    pub optdepends: Vec<String>,
    pub makedepends: Vec<String>,
}

impl Pkg {
    pub fn name(&self) -> Result<&str> {
        self.name
            .first()
            .context("Missing package name")
            .map(String::as_str)
    }

    pub fn version(&self) -> Result<&str> {
        self.version
            .first()
            .context("Missing package version")
            .map(String::as_str)
    }
}

type Reader = StreamingDecoder<fs::File, FrameDecoder>;

fn open(dir: &Path, pkg: &srcinfo::Pkg) -> Result<(Meta, tar::Archive<Reader>)> {
    let filename = pkg.filename();
    let path = dir.join(&filename);

    let meta = Meta {
        filename,
        ..Default::default()
    };

    let file = fs::File::open(&path).with_context(|| format!("Failed to open: {path:?}"))?;
    let zstd = StreamingDecoder::new(file)?;
    let tar = tar::Archive::new(zstd);
    Ok((meta, tar))
}

pub fn load(dir: &Path, pkg: &srcinfo::Pkg) -> Result<(Meta, Pkg)> {
    let (mut meta, mut tar) = open(dir, pkg)?;

    let mut pkg = None;
    for entry in tar.entries()? {
        let mut entry = entry?;
        let header = entry.header();
        trace!("Tar entry: {:?}", header);
        let path = entry.path()?;
        match path.to_str() {
            Some(".BUILDINFO") => (),
            Some(".INSTALL") => (),
            Some(".MTREE") => (),
            Some(".PKGINFO") => {
                let mut buf = String::new();
                entry.read_to_string(&mut buf)?;
                trace!("buf={buf:?}");
                pkg = Some(parse(&buf)?);
            }
            // everything else doesn't need processing
            _ => break,
        }
    }

    let mut file = tar.into_inner().into_inner();
    file.rewind()?;
    meta.checksum_stream(&mut file)?;
    debug!("Resolved package meta: {meta:?}");

    let pkg = pkg.context("Failed to locate .PKGINFO")?;
    Ok((meta, pkg))
}

pub fn parse(pkginfo: &str) -> Result<Pkg> {
    let mut pkg = Pkg::default();
    let mut pairs = [
        ("pkgname = ", &mut pkg.name),
        ("pkgbase = ", &mut pkg.base),
        ("pkgver = ", &mut pkg.version),
        ("pkgdesc = ", &mut pkg.desc),
        ("group = ", &mut pkg.groups),
        ("url = ", &mut pkg.url),
        ("license = ", &mut pkg.license),
        ("arch = ", &mut pkg.arch),
        ("builddate = ", &mut pkg.builddate),
        ("packager = ", &mut pkg.packager),
        ("size = ", &mut pkg.size),
        ("replaces = ", &mut pkg.replaces),
        ("conflict = ", &mut pkg.conflicts),
        ("provides = ", &mut pkg.provides),
        ("depend = ", &mut pkg.depends),
        ("optdepend = ", &mut pkg.optdepends),
        ("makedepend = ", &mut pkg.makedepends),
    ];
    for line in pkginfo.lines() {
        trace!("line = {line:?}");
        for (prefix, target) in &mut pairs {
            if let Some(value) = line.strip_prefix(*prefix) {
                target.push(value.to_string());
                break;
            }
        }
    }
    Ok(pkg)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple() {
        let pkginfo = "# Generated by makepkg 7.0.0\n# using fakeroot version 1.37.1.2\npkgname = librustls\npkgbase = librustls\nxdata = pkgtype=pkg\npkgver = 0.15.0-1\npkgdesc = Use rustls from languages other than Rust\nurl = https://github.com/rustls/rustls-ffi\nbuilddate = 1748609013\npackager = Unknown Packager\nsize = 4150754\narch = x86_64\nlicense = Apache-2.0\nlicense = MIT\nprovides = librustls.so=0.15.0-64\nprovides = rustls-ffi\ndepend = gcc-libs\ndepend = glibc\nmakedepend = cargo-c\nmakedepend = rust\n";
        let pkg = parse(pkginfo).unwrap();
        assert_eq!(
            pkg,
            Pkg {
                name: vec!["librustls".to_string()],
                base: vec!["librustls".to_string()],
                version: vec!["0.15.0-1".to_string()],
                desc: vec!["Use rustls from languages other than Rust".to_string()],
                groups: vec![],
                url: vec!["https://github.com/rustls/rustls-ffi".to_string()],
                license: vec!["Apache-2.0".to_string(), "MIT".to_string()],
                arch: vec!["x86_64".to_string()],
                builddate: vec!["1748609013".to_string()],
                packager: vec!["Unknown Packager".to_string()],
                size: vec!["4150754".to_string()],
                replaces: vec![],
                conflicts: vec![],
                provides: vec![
                    "librustls.so=0.15.0-64".to_string(),
                    "rustls-ffi".to_string()
                ],
                depends: vec!["gcc-libs".to_string(), "glibc".to_string()],
                optdepends: vec![],
                makedepends: vec!["cargo-c".to_string(), "rust".to_string()],
            }
        );
    }

    #[test]
    fn test_parse_conflict_replace() {
        let pkginfo = "# Generated by makepkg 7.0.0\n# using fakeroot version 1.37.1.2\npkgname = util-linux-libs\npkgbase = util-linux\nxdata = pkgtype=split\npkgver = 2.41-4\npkgdesc = util-linux runtime libraries\nurl = https://github.com/util-linux/util-linux\nbuilddate = 1748610944\npackager = Unknown Packager\nsize = 1570076\narch = x86_64\nlicense = BSD-2-Clause\nlicense = BSD-3-Clause\nlicense = BSD-4-Clause-UC\nlicense = GPL-2.0-only\nlicense = GPL-2.0-or-later\nlicense = GPL-3.0-or-later\nlicense = ISC\nlicense = LGPL-2.1-or-later\nlicense = LicenseRef-PublicDomain\nreplaces = libutil-linux\nconflict = libutil-linux\nprovides = libutil-linux\nprovides = libblkid.so=1-64\nprovides = libfdisk.so=1-64\nprovides = libmount.so=1-64\nprovides = libsmartcols.so=1-64\nprovides = libuuid.so=1-64\ndepend = glibc\ndepend = sqlite\noptdepend = python: python bindings to libmount\nmakedepend = bash-completion\nmakedepend = bison\nmakedepend = flex\nmakedepend = git\nmakedepend = libcap-ng\nmakedepend = libxcrypt\nmakedepend = meson\nmakedepend = sqlite\nmakedepend = systemd\n";
        let pkg = parse(pkginfo).unwrap();
        assert_eq!(
            pkg,
            Pkg {
                name: vec!["util-linux-libs".to_string()],
                base: vec!["util-linux".to_string()],
                version: vec!["2.41-4".to_string()],
                desc: vec!["util-linux runtime libraries".to_string()],
                groups: vec![],
                url: vec!["https://github.com/util-linux/util-linux".to_string()],
                license: [
                    "BSD-2-Clause",
                    "BSD-3-Clause",
                    "BSD-4-Clause-UC",
                    "GPL-2.0-only",
                    "GPL-2.0-or-later",
                    "GPL-3.0-or-later",
                    "ISC",
                    "LGPL-2.1-or-later",
                    "LicenseRef-PublicDomain"
                ]
                .into_iter()
                .map(String::from)
                .collect(),
                arch: vec!["x86_64".to_string()],
                builddate: vec!["1748610944".to_string()],
                packager: vec!["Unknown Packager".to_string()],
                size: vec!["1570076".to_string()],
                replaces: vec!["libutil-linux".to_string()],
                conflicts: vec!["libutil-linux".to_string()],
                provides: [
                    "libutil-linux",
                    "libblkid.so=1-64",
                    "libfdisk.so=1-64",
                    "libmount.so=1-64",
                    "libsmartcols.so=1-64",
                    "libuuid.so=1-64"
                ]
                .into_iter()
                .map(String::from)
                .collect(),
                depends: vec!["glibc".to_string(), "sqlite".to_string()],
                optdepends: vec!["python: python bindings to libmount".to_string()],
                makedepends: [
                    "bash-completion",
                    "bison",
                    "flex",
                    "git",
                    "libcap-ng",
                    "libxcrypt",
                    "meson",
                    "sqlite",
                    "systemd"
                ]
                .into_iter()
                .map(String::from)
                .collect(),
            }
        );
    }
}
